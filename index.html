<!DOCTYPE html>

<meta charset="utf-8">

<head>
  <link rel="stylesheet" href="styles.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.12.6/js/standalone/selectize.min.js" integrity="sha256-+C0A5Ilqmu4QcSPxrlGpaZxJ04VjsRjKu+G82kl5UJk=" crossorigin="anonymous"></script>

  <script src="https://cdn.jsdelivr.net/npm/d3-dispatch@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-selection@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-drag@3"></script>

  <script src="https://d3js.org/d3.v4.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.12.6/css/selectize.bootstrap3.min.css" integrity="sha256-ze/OEYGcFbPRmvCnrSeKbRTtjG4vGLHXgOqsyLFTRjg=" crossorigin="anonymous" />
</head>
<body>
<!-- Create a div where the graph will take place -->
<div  style="text-align:left;font-family: Verdana, sans-serif;font-size: 24px;color:#000000;">BOCC Visualization</div>
<div  style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#000000;">Search clusters by filtering by genes or diseases of interest</div>

<div  style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#000000;max-width: 50%;">
  <select id="select-node"  placeholder="Filter by genes or HP terms...",  size="2"></select>
</div>
<div id="sort-form" style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#7b7b7b;max-width: 50%;"> 
    Sort by:
    <input type="radio" class="form-check-input" id="sort-count" name="optradio" value="option1" checked>
    <label class="form-check-label" for="radio1">matching terms</label>
    <input type="radio" class="form-check-input" id="sort-pvalue" name="optradio" value="option2">
    <label class="form-check-label" for="radio2">discovery pvalue</label>
</div>  

<div id="layout-form" style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#7b7b7b;max-width: 50%;"> 
  Network Layout:
  <input type="radio" class="form-check-input" id="layout-spring" name="optradio1" value="option1" checked>
  <label class="form-check-label">spring</label>
  <input type="radio" class="form-check-input" id="layout-HPO" name="optradio1" value="option2">
  <label class="form-check-label">HPO radial</label>
  <input type="radio" class="form-check-input" id="layout-bipartite" name="optradio1" value="option2">
  <label class="form-check-label">bipartite</label>
</div>  

<!-- <div id="layout-form" style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#7b7b7b;max-width: 50%;"> 
  <label><input type="checkbox" value="" id="checkbox1"> color genes by tissue expression</label>
</div>  
<div id="layout-form" style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#7b7b7b;max-width: 50%;"> 
  <label><input type="checkbox" value="" id="checkbox1"> size genes by lof</label>
</div>   -->
<div style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#7b7b7b;max-width: 50%;"> 
  <label><input type="checkbox" value="" id="hpoParents"> include out of cluster HPO parents</label>
</div>  


<table id="cluster-info" class="center" hidden="hidden" style="text-align:center;font-family: Verdana, sans-serif;font-size: 12px;color:#252525;">
  <tr>
    <td>
      <a id="previous" class="previous" hidden="hidden"> &#8249; </a>
    </td>
    <td>
      <small>Cluster <span id="current-cluster">10</span> of <span id="total-clusters">50</span></small><br>
      <small>Cluster ID: <span id="cluster-id">ParisWalkYrap</span></small><br>
      <small>Matching Search Terms: <span id="matching-count">1</span>/<span id="total-count">10</span></small><br>
      <small>Discovery P-Value: <span  id="pval">0.234</span></small><br>
    </td>
    <td>
      
      <a id="next" class="next" hidden="hidden">&#8250;</a>
    </td>
  </td>
  </td>
</table>



      <div id="my_dataviz"></div>



</body>
<script>
  

    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 10, bottom: 10, left: 10},
      width = 800 - margin.left - margin.right,
      height = 800 - margin.top - margin.bottom;

    let zoom = d3.zoom()
      .scaleExtent([1, 20])
      .translateExtent([[0, 0], [width, height]]);

    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform","translate(" + margin.left + "," + margin.top + ")");

    d3.json("https://sky123martin.github.io/BOCC/network_extended.json", function(err,data){


        // append the svg object to the body of the page
      min_x = Number.MAX_VALUE,
      max_x = -Number.MAX_VALUE;
      min_y = Number.MAX_VALUE,
      max_y = -Number.MAX_VALUE;
      data.nodes.forEach(function (o) {
                min_x = Math.min(min_x, o["x"]);
                max_x = Math.max(max_x, o["x"]);
                min_y = Math.min(min_y, o["y"]);
                max_y = Math.max(max_y, o["y"]);
        });

      // Add X axis
      var normX = d3.scaleLinear()
          .domain([min_x, max_x])
          .range([0, 0.75]);

      // Add Y axis
      var normY = d3.scaleLinear()
          .domain([min_y, max_y])
          .range([0, 0.75]);
      
      var xZoom = d3.scaleLinear()
        .domain([min_x, max_x])
        .range([ 0, width ]);

      // Add Y axis
      var yZoom = d3.scaleLinear()
          .domain([min_y, max_y])
          .range([ height, 0]);

  // ONLOAD

  function loadAll(){
    let max_clusters = data["# of clusters"]
      // Add X axis
      let grid_size = Math.ceil(Math.sqrt(max_clusters));
      var x = d3.scaleLinear()
        .domain([0, grid_size])
        .range([ 0, width ]);

      // Add Y axis
      var y = d3.scaleLinear()
          .domain([0, grid_size])
          .range([0, height]);
    
      function gridY(a) {return Math.ceil(a/grid_size);}
      function gridX(a) {return a%grid_size;}

      var node = svg
        .selectAll("circle")
        .data(data.nodes)
        .enter()
        .append("circle")
            .attr("id", function (d) { return d.id; } )
            .attr("stroke", "white")
            .attr("stroke-width", 0)
            .attr("cx", function (d) { 
              d.defaultx = d.x;
              return x(gridX(d.cluster_id)+normX(d.x)); } )
            .attr("cy", function (d) { 
              d.defaulty = d.y;
              return y(gridY(d.cluster_id)+normY(d.y)); } )
            .attr("r", 1)
            .attr("fill", function(d) { 
              if (d.id[2]==":"){
                return "#27476E";
              }else{
                return "#81ADC8";
              };});
    
  }

  $(document).ready(function() {
    buildSelectize();
    loadAll();
  });

// FORCE DIRECTED LAYOUT
function forceDirected(cluster, selectedNodes) {
  d3.json("https://raw.githubusercontent.com/sky123martin/BOCC/main/clusters/"+cluster.replace(":",".")+".json", function(clusterdata) {

  var edges = clusterdata["edges"];
  var nodes = clusterdata["nodes"];
  var node_list = [];
  var tmp = [];

  if(document.getElementById("hpoParents").checked){
    nodes = nodes.concat(clusterdata["hpoParentNodes"]);
    edges = edges.concat(clusterdata["hpoParentEdges"]);
  }

  node_list.forEach(function (o)
   {
    if(o[2]==":"){
      min_d = Math.min(min_d, data.hpoDepth[o]);
      max_d = Math.max(max_d, data.hpoDepth[o]);
    }});      

  var x = d3.scaleLinear()
    .domain([0, 0.75])
    .range([ 0, width]);

  var y = d3.scaleLinear()
      .domain([0, 0.75])
      .range([0, height]);

  // filter nodes and edges from a specific cluster
  // data.nodes.forEach(function(n){if(n.cluster==cluster){nodes.push(n);}});
  nodes.forEach(function(n){node_list.push(n.id)});
  // data.edges.forEach(function(e){if(node_list.includes(e.source) & node_list.includes(e.target)){edges.push(e);}});
  min_d = Number.MAX_VALUE,
  max_d = -Number.MAX_VALUE;
  node_list.forEach(function (o) {
    if(o[2]==":"){
      console.log(o, data.hpoDepth[o])
      min_d = Math.min(min_d, data.hpoDepth[o]);
      max_d = Math.max(max_d, data.hpoDepth[o]);
    }});      

  var cScale = d3.scaleLinear()
      .domain([min_d ,max_d])
      .range(["black","lightgrey"]);

  console.log(min_d, max_d, cScale(min_d),cScale(max_d/2),cScale(max_d))
  // radial scale
  var radialScale = d3.scaleLinear()
      .domain([min_d, max_d])
      .range([width*5/12, width*2/12]);

  // bipartite scale
  var bipartiteScale = d3.scaleLinear()
      .domain([min_d, max_d])
      .range([width*7/10, width*5/10]);

  // initialize the edges
  var link = svg
    .selectAll("line")
    .data(edges)
    .enter()
    .append("line")
      .style("stroke", "black")
      .style("stroke-width", 1)
      .style("opacity", 0.1);

  // initialize the nodes

  svg
    .selectAll("circle")
    .remove();

  var node = svg
        .selectAll("circle")
        .data(nodes)
        .enter()
        // .filter(function (d) { return d.cluster==cluster; } )
        .append("circle")
            .attr("id", function (d) { return d.id; } )
            .attr("stroke", "white")
            .attr("stroke-width", 0)
            .attr("cx", function (d) { 
              if(Object.keys(d).includes("x")){
                d.x = x(normX(d.x));
                return x(normX(d.x)); 
              }else{
                d.x = width/2;
                return width/2; 
              }})
            .attr("cy", function (d) { 
              if(Object.keys(d).includes("y")){
                d.y = y(normY(d.y));
                return y(normY(d.y)); 
              }else{
                d.y = height/2;
                return  height/2; 
              }})
            .attr("r", 10)
            .attr("fill", function(d) { 
              if(d.type=="HPO Parent"){
                return "red";
              }
              if (d.id[2]==":"){
                return "#27476E";
              }else{
                return "#81ADC8";
              };});

  // initialize the labels
  var labels = svg
    .selectAll("text")
    .data(nodes)
    .enter()
    .append("text")
      .style("font-family","Tahoma")
      .style("font-size","10px")
      .style("opacity", 0.60);
 
  // simulate network with repulision and springs
  var simulation = d3.forceSimulation(nodes)
      .force('charge', d3.forceManyBody())
      .force("link", 
        d3.forceLink()
            .id(function(d) { return d.id; }) // This provide  the id of a node
            .links(edges) // and this the list of links
       )
      .force("charge", d3.forceManyBody().strength(-200)) // repulsion between nodes
      .force("collide", d3.forceCollide(document.getElementById("layout-bipartite").checked ? 10 : 20).iterations(10)) // 15 is raduis and run collisions to reduce overlap
      .force("center", d3.forceCenter(width * .5, height * .5)) // attracts nodes to the center
      .force("radial",d3.forceRadial(d => d.id[2]===":" ? radialScale(data.hpoDepth[d.id]): 0, width / 2, height / 2).strength(d => document.getElementById("layout-HPO").checked ? (d.id[2]===":" ? 5 : 1): 0 ))
      .force("x", d3.forceX().x(d => (d.id[2]===":" ? bipartiteScale(data.hpoDepth[d.id]):width*3/ 10)).strength(d => document.getElementById("layout-bipartite").checked ? 200: 0 ))
      .on("tick", ticked)
      .on("end", function(d){
      // after nodes draw labels
        labels
          .attr("id",function(d) {return d.id})
          .style("background-color","white")
          .attr("x", function (d) { return   2 + Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )); })
          .attr("y", function(d) { return -10 + Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); })
          // .append('tspan')
          .attr("class","nodeID")
          .attr("text-anchor", "start")
          .text(function(d) {
            if(d.id[2]===":" && d.id in data.nodeLabels){
              return data.nodeLabels[d.id];
            }else{
              return d.id;
            }});

        labels
          .append('tspan')
          .attr("class","fullLabel")
          .style("background-color","white")
          .attr("x", function (d) { return   10 + Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )); })
          .attr("y", function(d) { return -2 + Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); })
          .attr("text-anchor", "start")
          // function(d) {
          //   if(d.id[2]!=":"){
          //     return "middle"
          //   }else if( (2 + Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )))>width/2){
          //     return "start"
          //   }else{
          //     return "end"
          //   };})
          .text(function(d) {
            return ""
          });

          // link
          //   .filter(function(d){
          //     console.log( d.source.id, d.target.id,(d.source.id[2]!=":" && d.target.id[2]!=":"));
          //     return (d.source.id[2]!=":" && d.target.id[2]!=":");})
          //   .append('path')
          //   .attr('opacity',1)
          //   .attr('d', function (d) {
          //     console.log(d.source.id,d.source.y)
          //     start = d.source.y;   // X position of start node on the X axis
          //     x = d.source.x; 
          //     end = d.target.y;      // X position of end node
          //     return ['M', x, start,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)
          //       'A',                            // This means we're gonna build an elliptical arc
          //       (start - end)/2*4, ',',    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance
          //       (start - end)/2, 0, 0, ',',
          //       start < end ? 1 : 0, x, ',', end] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.
          //       .join(' ');
          //   });
          
        labels
          .on("click", function(d){
            if(d.id[2]==':'){
              window.open("https://hpo.jax.org/app/browse/term/"+d.id);
            }else{
              window.open("https://gnomad.broadinstitute.org/gene/"+d.id);
              window.open("https://gtexportal.org/home/gene/"+d.id);
            };  
            });
        labels
          .raise();
        return form.enable(); // enable form
      });
  
  // network scaling factor
  var scaling_factor = 1;

  node
      .filter(function (d) {return document.getElementById("layout-bipartite").checked ? (d.id[2]==":" ? true : false) : true})
      .call(d3.drag().on("drag", dragged))

  node
    .on('mouseover', function (d) {
      // Highlight the nodes: every node is green except of him
      // Highlight the connections
      node
        .style('opacity',0.3);
      labels
        .style('opacity',0.03);
      link
        .style('opacity',0.01);
      
      d3.selectAll("tspan").filter(function(n) { return n.id === d.id; }).text( d.id[2]===":" ? d.id : (d.id in data.nodeLabels ? data.nodeLabels[d.id]:""));

      link
        .filter(function(link_d){return link_d.source.id === d.id || link_d.target.id === d.id;})
        .style('opacity', function (link_d) { 
            node
              .filter(function(l) { return link_d.source.id === l.id || link_d.target.id === l.id; })
              .style('opacity', 1)
            labels
              .filter(function(l) { return link_d.source.id === l.id || link_d.target.id === l.id; })
              .style('opacity',0.8)
            return 0.3;
        })
    })
    .on('mouseout', function (d) {
      d3.selectAll("tspan")
        .filter(function(n) { return n.id === d.id; })
        .text(function(d) {
            return ""
          });

      node
        .style('opacity', 1)
      link
        .style('opacity',  0.1)
      labels
        .style('opacity',  0.6)
    });

  // updating the nodes position during dragging
  function dragged(d) {
    d.x = d3.event.x, d.y = d3.event.y;
    d3.select(this).attr("cx", d.x*scaling_factor).attr("cy", d.y*scaling_factor);
    link.filter(function(l) { return l.source === d; }).attr("x1", d.x*scaling_factor).attr("y1", d.y*scaling_factor);
    link.filter(function(l) { return l.target === d; }).attr("x2", d.x*scaling_factor).attr("y2", d.y*scaling_factor);
    labels.filter(function(n) { return n.id === d.id; }).attr("x", 2+d.x*scaling_factor).attr("y",-10+d.y*scaling_factor);
    d3.selectAll("tspan").filter(function(n) { return n.id === d.id; }).attr("x", 10+d.x*scaling_factor).attr("y",-2+d.y*scaling_factor);
    node
        .style('opacity', 1)
      link
        .style('opacity',  0.1)
      labels
        .style('opacity',  0.5)
  }
  // run after force simulation
  
  function ticked() {
    //draw nodes
    node
      .interrupt()
      .attr("stroke", "White")
      .style("stroke-width",1)
      .style("fill", function (d) {
        if (d.id[2]==":"){
          return cScale(parseInt(data.hpoDepth[d.id]));
        }else{
          return "lightblue";
        }
      })
      .attr("cx", function (d) { 
        d.x = Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor ));
        return Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )); })
      .attr("cy", function(d) {
        d.y = Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); 
        return Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); })
      .attr("r", function(d) {return document.getElementById("layout-bipartite").checked ? 5: (selectedNodes.includes(d.id)? 15:10)})

    // raise nodes above edges
    node
      .raise();
    // draw edges

    link
      .style('opacity',  0.1)
      .attr("x1", function(d) { return Math.max(margin.left, Math.min(width - margin.left, d.source.x*scaling_factor )); })
      .attr("y1", function(d) { return Math.max(margin.left, Math.min(height - margin.left, d.source.y*scaling_factor ));})
      .attr("x2", function(d) { return Math.max(margin.left, Math.min(width - margin.left, d.target.x*scaling_factor )); })
      .attr("y2", function(d) { return Math.max(margin.left, Math.min(height - margin.left, d.target.y*scaling_factor )); });
    };


    })};

  ////////////////////////
  // GENES/HP TERM FORM //
  ////////////////////////
  
  function displayCluster(cluster_info, selections){
    var cluster = cluster_info["cluster"];


    // clean up network drawing
    svg.selectAll("circle")
      .attr("fill", function(d) { 
            if (d.id[2]==":"){
              return "#27476E";
            }else{
              return "#81ADC8";
            };});
              
    svg.selectAll("line").remove();
    svg.selectAll("text").remove();
    
    // remove all nodes
    svg.selectAll("circle")
      .filter(function(d){return cluster!=d.cluster;})
      .remove()
    
    if(cluster==cluster){
      // ENTER CLUSTER NODES
      forceDirected(cluster, selections);
    }else{
      loadAll();
    }
  }
  
  function processSelection(ranking=1) {
    let selections = form.items;
    if(selections.length>0){
      console.log(selections);
      let sortByCount = document.getElementById("sort-count").checked;
      // filter to only the filter nodes
      let filteredClusters = {};
      var node;
      var selectedClusters = [];
      // count genes and hpo terms in cluster
        // union of all cluster with selected genes and HPS
        // for each selection
        // find clusters it is in and add one to cluster score
        for (let i = 0; i < selections.length; i++) {
          if(data.clusters.includes(selections[i])){
            selectedClusters.push(selections[i])
            
            if (!(selections[i] in filteredClusters)){// if cluster has already been added to dict, update its count
                filteredClusters[selections[i]] = {}
                filteredClusters[selections[i]]["HPO count"] = 0;
                filteredClusters[selections[i]]["gene count"] = 0;
                filteredClusters[selections[i]]["count"] = 0;
                filteredClusters[selections[i]]["pval"] = data.pval[selections[i]];
              }
          }else{
          data.nodes.forEach(function(node){
            if( node.id == selections[i]){
              if (Object.keys(filteredClusters).includes(node.cluster)){// if cluster has already been added to dict, update its count
                filteredClusters[node.cluster][((node.id[2]==":") ? "HPO count" : "gene count")] += 1;
                filteredClusters[node.cluster]["count"] += 1;
              }else{// if cluster hasnt then add to dict
                filteredClusters[node.cluster] = {}
                filteredClusters[node.cluster]["HPO count"] = ((node.id[2]==":") ? 1 : 0);
                filteredClusters[node.cluster]["gene count"] = ((node.id[2]==":") ? 0 : 1);
                filteredClusters[node.cluster]["count"] = 1;
                filteredClusters[node.cluster]["pval"] = data.pval[node.cluster];
              }
            }
          })
        }
        }
      
      // convert dict to list of dicts
      var rankedClusters = [];
      Object.keys(filteredClusters).forEach(function(cluster){
        if(selectedClusters.length==0 || selectedClusters.includes(cluster) ){
          rankedClusters.push({"cluster":cluster,
                              "HPO count": filteredClusters[cluster]["HPO count"],
                              "gene count": filteredClusters[cluster]["gene count"],
                              "count": filteredClusters[cluster]["count"],
                              "pval": filteredClusters[cluster]["pval"]});
          }});

    // Sort by either count or pval, break ties with other metric
      rankedClusters = rankedClusters.sort(function (a, b) {
        if(sortByCount){
          return b["count"] - a["count"] || a["pval"] - b["pval"];
        }else{
          return  a["pval"] - b["pval"] || b["count"] - a["count"];
        }
      });

      // console.log(rankedClusters, selections)
      document.getElementById("cluster-info").hidden = "";
      document.getElementById("current-cluster").innerHTML = ranking;
      document.getElementById("total-clusters").innerHTML = rankedClusters.length;
      document.getElementById("cluster-id").innerHTML = rankedClusters[ranking-1]["cluster"];
      document.getElementById("matching-count").innerHTML = rankedClusters[ranking-1]["count"];
      document.getElementById("total-count").innerHTML = selections.length-selectedClusters.length;
      document.getElementById("pval").innerHTML = rankedClusters[ranking-1]["pval"];

      if( ranking<rankedClusters.length){document.getElementById("next").hidden = "";
      }else{ document.getElementById("next").hidden = "hidden";}

      console.log(ranking, rankedClusters.length)
      if( ranking>1){document.getElementById("previous").hidden = "";
      }else{document.getElementById("previous").hidden = "hidden";}

      displayCluster(rankedClusters[ranking-1], selections);
  }else{
    svg.selectAll("line").remove();
    svg.selectAll("text").remove();
    svg.selectAll("circle").remove();
    document.getElementById("cluster-info").hidden = "hidden";
    loadAll();
  }
  };
  
  function updateSelectize(){
    var selectedOptions = Array.from(form.items);
    var optionsArray = [];
    data.genes.forEach(function(o){if(!selectedOptions.includes(o)){optionsArray.push({name:o, value:o, group:"gene"})}});
    data.diseases.forEach(function(o){if(!selectedOptions.includes(o)){optionsArray.push({name:o, value:o, group:"HP"})}});
    data.clusters.forEach(function(o){if(!selectedOptions.includes(o)){optionsArray.push({name:o, value:o, group:"cluster"})}});
    form.clearOptions();
    optionsArray.forEach(function(o){form.addOption(o)})
  }

  function buildSelectize(){
    var optionsArray = [];
    
    data.genes.forEach(function(o){optionsArray.push({name:o, value:o, group:"gene"})});
    data.diseases.forEach(function(o){optionsArray.push({name:o, value:o, group:"HP"})});
    data.clusters.forEach(function(o){optionsArray.push({name:o, value:o, group:"cluster"})});

    $form = $("#select-node")
                .selectize({
                      valueField: 'name',
                      labelField: 'value',
                      searchField: ['name'],
                      options: optionsArray,
                      optgroups:[
                        {value:"gene", label: "gene"},
                        {value:"HP", label: "HP"},
                        {value:"cluster", label: "cluster"},
                      ],
                      optgroupField: 'group',
                      delimiter:',',
                      create: false,
                      sortField: "text",
                      maxItems: 10,
                      text:true,
                      onChange: function (){updateSelectize();},
                      onDropdownClose: function (){processSelection(1);}
                  });

    form = $form[0].selectize;   
    form.setValue([])  
  }   
  function clickNext(){
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML)+1);
  };

  function clickPrevious(){
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML)-1);
  };

  $('.next').mousedown(function(){clickNext();});
  $('.searchDropdown').mousedown( function(){$('.searchFilters').collapse('toggle');});
  $('.previous').mousedown(function(){clickPrevious();});
  document.getElementById("sort-form").addEventListener('click', function (event) {
    if (event.target && event.target.matches("input[type='radio']")) {
        processSelection();
    }
  });

  document.getElementById("hpoParents").addEventListener('click',function(){processSelection(parseInt(document.getElementById("current-cluster").innerHTML));});


  document.getElementById("layout-form").addEventListener('click', function (event) {
  if (event.target && event.target.matches("input[type='radio']")) {
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML));
  }
});



});


    </script>