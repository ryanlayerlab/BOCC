<!DOCTYPE html>

<meta charset="utf-8">

<head>  
  <script src="https://cdn.jsdelivr.net/npm/d3-dispatch@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-selection@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-drag@3"></script>
  <script src="https://d3js.org/d3.v4.js"></script>
  
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.12.6/js/standalone/selectize.min.js" integrity="sha256-+C0A5Ilqmu4QcSPxrlGpaZxJ04VjsRjKu+G82kl5UJk=" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.12.6/css/selectize.bootstrap3.min.css" integrity="sha256-ze/OEYGcFbPRmvCnrSeKbRTtjG4vGLHXgOqsyLFTRjg=" crossorigin="anonymous" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <link rel="stylesheet" href="styles.css">

</head>
<body>

  <br>

<div style="text-align:right;">
BOCC | paper | code | contact
</div>

<br>

<div  class="selectize">
  <select id="select-node"  placeholder="Filter by genes or HP terms...",  size="2"></select>
</div>

<div  class="displayOptions">
  <div class="container">
    <div class="row">
      <div class="col" style="max-width: 80%;">

      </div>
      <div class="col-auto">
        <span class="expandOptions" id="sort-form-title"> cluster ranking &or; </span>
        <div id="sort-form" hidden="hidden"> 
            <input type="radio" class="form-check-input" id="sort-count" name="optradio" value="option1" checked>
            <label class="form-check-label" for="radio1">matching terms</label><br>
            <input type="radio" class="form-check-input" id="sort-pvalue" name="optradio" value="option2">
            <label class="form-check-label" for="radio2">discovery pvalue</label><br>
        </div>  
      </div>
      <div class="col-auto">
        <span class="expandOptions" id="layout-form-title"> view &or; </span>
        <div id="layout-form" hidden> 
          <input type="radio" class="form-check-input" id="layout-spring" name="optradio1" value="option1" checked>
          <label class="form-check-label">spring network</label><br>
          <input type="radio" class="form-check-input" id="layout-HPO" name="optradio1" value="option2">
          <label class="form-check-label">HPO radial network</label><br>
          <input type="radio" class="form-check-input" id="layout-bipartite" name="optradio1" value="option2">
          <label class="form-check-label">bipartite network</label><br>
        </div>  
      </div>
      <div class="col-auto">
        <span class="expandOptions" id="misc-form-title"> display &or; </span>
        <div id="misc-form" hidden> 
          <label><input type="checkbox" value="" id="hpoParents"> HPO parents</label><br>
          <label><input type="checkbox" value="" id="hpoLabel"> full HPO label</label><br>
          <label><input type="checkbox" value="" id="geneLabel"> full gene label</label><br>
        </div>
      </div>
    </div>
  </div>
</div>

<div>
  <div class="container">
    <div class="row cluster-info" id="cluster-info" hidden>
        <div class="col" style="max-width: 2%;"></div>
        <div class="col" style="max-width: 80%;">
        <small><span id="cluster-id"></span></small><br>
        <small>terms <span id="matching-count"></span>/<span id="total-count"></span>
        | p-value=<span  id="pval"></span>
        | cluster <span id="current-cluster"></span>/<span id="total-clusters"></span></small> 
      </div>

        <div class="col" style="max-width: 2%;"></div>
      </div>
    <div class="row" >
      <div class="col" style="max-width: 2%;">
        <br><br><br><br><br><br><br><br>
        <a id="previous" class="previous" hidden="hidden"> &#8249; </a>
      </div>
      <div class="col-auto">
        <div id="network_viz" class="svg-container"></div>
      </div>
      <div class="col-auto">
        <div id="expression_viz" class="svg-container"></div>
      </div>
      <div class="col"  style="max-width: 2%;">
        <br><br><br><br><br><br><br><br>
        <a id="next" class="next" hidden="hidden">&#8250;</a>
      </div>
    </div>
  </div>
</div>




</body>
<script>
  

    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 10, bottom: 10, left: 10},
      width = 600 - margin.left - margin.right,
      height = 600 - margin.top - margin.bottom;

    let zoom = d3.zoom()
      .scaleExtent([1, 20])
      .translateExtent([[0, 0], [width, height]]);

    // append the svg object to the body of the page
    var svg = d3.select("#network_viz")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform","translate(" + margin.left + "," + margin.top + ")")

  // append the svg object to the body of the page
  var svgE = d3.select("#expression_viz")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform","translate(" + margin.left + "," + margin.top + ")")

    d3.json("https://sky123martin.github.io/BOCC/network_2022.json", function(err,data){
      console.log(err);
        // append the svg object to the body of the page
      min_x = Number.MAX_VALUE,
      max_x = -Number.MAX_VALUE;
      min_y = Number.MAX_VALUE,
      max_y = -Number.MAX_VALUE;
      data.nodes.forEach(function (o) {
                min_x = Math.min(min_x, o["x"]);
                max_x = Math.max(max_x, o["x"]);
                min_y = Math.min(min_y, o["y"]);
                max_y = Math.max(max_y, o["y"]);
        });

      // Add X axis
      var normX = d3.scaleLinear()
          .domain([min_x, max_x])
          .range([0, 0.75]);

      // Add Y axis
      var normY = d3.scaleLinear()
          .domain([min_y, max_y])
          .range([0, 0.75]);
      
      var xZoom = d3.scaleLinear()
        .domain([min_x, max_x])
        .range([ 0, width ]);

      // Add Y axis
      var yZoom = d3.scaleLinear()
          .domain([min_y, max_y])
          .range([ height, 0]);

  // ONLOAD

  function loadAll(){
    let max_clusters = data["# of clusters"]
      // Add X axis
      let grid_size = Math.ceil(Math.sqrt(max_clusters));
      var x = d3.scaleLinear()
        .domain([0, grid_size])
        .range([ 0, width ]);

      // Add Y axis
      var y = d3.scaleLinear()
          .domain([0, grid_size])
          .range([0, height]);
    
      function gridY(a) {return Math.ceil(a/grid_size);}
      function gridX(a) {return a%grid_size;}

      var node = svg
        .selectAll("circle")
        .data(data.nodes)
        .enter()
        .append("circle")
            .attr("id", function (d) { return d.id; } )
            .attr("stroke", "white")
            .attr("stroke-width", 0)
            .attr("cx", function (d) { 
              d.defaultx = d.x;
              return x(gridX(d.cluster_id)+normX(d.x)); } )
            .attr("cy", function (d) { 
              d.defaulty = d.y;
              return y(gridY(d.cluster_id)+normY(d.y)); } )
            .attr("r", 1)
            .attr("fill", function(d) { 
              if (d.id[2]==":"){
                return "darkgrey";
              }else{
                return "#059fa0";
              };});

    //return processSelection(ranking = 1,selections = ['BRCA1']);
    // displayCluster({"cluster": 'paris.cesna.2021:12792', "HPO count": 0, "gene count": 1, "count": 1, "pval": 0.005847958382219},['BRCA1']);
    // displayCluster({"cluster": 'paris.walktrap.2021:1015', "HPO count": 0, "gene count": 1, "count": 1, "pval": 0.009},['A2M']);
    
  }

  $(document).ready(function() {
    buildSelectize();
    loadAll();
  });


  
  // FORCE DIRECTED LAYOUT
  function forceDirected(cluster, selectedNodes) {
  // function geneLayout(cluster, selectedNodes) {
  
    svgE.selectAll("rect").remove();
    svgE.selectAll("line").remove();
    svgE.selectAll("text").remove();
    svgE.selectAll("circle").remove();
  
    d3.json("https://raw.githubusercontent.com/sky123martin/BOCC/main/clusters_2022/"+cluster.replace(":",".")+".json", function(clusterdata) {
      d3.json("https://raw.githubusercontent.com/sky123martin/BOCC/main/clusters_2022/"+cluster.replace(":",".")+".json", function(clusterdata) {
      var genes = [];
      var tissues = [];
      var gene_tissues = [];
      var tissue_count = {};
      
      clusterdata["nodes"].forEach(function(n){
          if(n.id[2]!=":" && Object.keys(data["tissueExpression"]).includes(n.id) && Object.keys(data["tissueExpression"][n.id]).includes("specificity")){
            genes.push(n.id);
            Object.keys(data["tissueExpression"][n.id]).forEach(function(t){
                                              t!="specificity" ? tissues.push(t):"";
                                              if( t!="specificity"){
                                                gene_tissues.push({"gene":n.id,"tissue":t,"expression":t!="specificity" ? data["tissueExpression"][n.id][t]:20});
                                              };
                                              Object.keys(tissue_count).includes(t) ? tissue_count[t] = tissue_count[t]+1 : tissue_count[t]=1;
                                            });
            let geneExpression = data["tissueExpression"][n.id];
            geneExpression["specificity"] =-1;
            tissues[n.id] = Object.entries(geneExpression).reduce((a, b) => a[1] > b[1] ? a : b)[0];
          }else if (n.id[2]!=":"){
            console.log(n.id);
            genes.push(n.id);
          }
        });
  
      tissues = Array.from(new Set(tissues)).sort();
  
      tissues = tissues.sort()
                    .map(function(d){return ([d, tissue_count[d]])})
                    .sort((first, second) => { return second[1]-first[1]})
                    .map(function(d){return d[0]});
  
      // tissues.unshift("specificity");
  
      var max_expression = -Number.MAX_VALUE
      var min_expression = Number.MAX_VALUE;
  
      gene_tissues.forEach(function(n){
        max_expression = Math.max(max_expression, n.expression);
        min_expression = Math.min(min_expression, n.expression);
      });
  
      var maxwidth =  0.4*width/(tissues.length+1);
      var maxheight =  0.8*height/(genes.length+1);
  
      var tissueX = d3.scaleBand()
                      .domain(tissues)
                      .range([width*0.2, width*0.6])
                      .padding(5);
                      
      // var tissueColors = d3.scaleOrdinal()
      //                 .domain(tissues)
      //                 .range(["lightgrey","#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#ffffbf","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2"]);//.sort((a, b) => 0.5 - Math.random()));
      var expressionOpacity = d3.scaleLinear()
        .domain([0, max_expression])
        .range([0,100]);//.sort((a, b) => 0.5 - Math.random()));
      
      var max_eo = 1;
      var min_eo = 0;
      genes.forEach(function(n){
        if( !isNaN(data["oeLOF"][n])){
          max_eo = Math.max(max_eo, data["oeLOF"][n]);
          min_eo = Math.min(min_eo, data["oeLOF"][n]);
        }
      });
      console.log(min_eo,max_eo);
  
      var eoScale = d3.scaleLinear()
          .domain([0, max_eo])
          .range([0.125*width, 0.2*width]);
  
      genes = genes.sort()
                    .map(function(d){return (Object.keys(data["oeLOF"]).includes(d) ? [d, data["oeLOF"][d]] : [d, Number.MAX_VALUE])})
                    .sort((first, second) => { return first[1] - second[1]})
                    .map(function(d){return d[0]});
      
      var geneY = d3.scaleBand()
                    .domain(genes)
                    .range([height*0.1, height*0.9])
                    .padding(5);
      
      var geneLabels = svgE.selectAll("genetext")
                      .data(genes)
                      .enter()
                      .append("text")
                        .attr("id", function(d) { return d;})
                        .attr("x", function(d) { return width*0.1; })
                        .attr("y", function(d) { return geneY(d); })
                        .text(function(d) { return d;})
                        .attr("class","gene-labels")
                        .attr("text-anchor","end")
  
      var opacityScale = d3.scaleLinear()
                      .domain([min_expression, max_expression])
                      .range([0, 100]);
  
      var expressionNodes = svgE.selectAll("rect")
                      .data(gene_tissues)
                      .enter()
                      .append("rect")
                        .attr("id", function (d) { return d.gene+"_"+d.tissue; } )
                        .attr("opacity", function (d) {return  expressionOpacity(d.expression);})
                        .attr("x", function (d) {return tissueX(d.tissue)-maxwidth/2;})
                        .attr("y", function (d) {return geneY(d.gene)-maxheight/2;})
                        .attr("width", maxwidth)
                        .attr("height", maxheight)
                        .attr("fill", "#036666");
    // Lines
    var horzLine = svgE.selectAll("lines")
                .data(genes)
                .enter()
                .append("line")
                  .attr("x1", tissueX(tissues[0])-maxwidth/2)
                  .attr("x2", tissueX(tissues[tissues.length-1])+maxwidth/2)
                  .attr("y1", function(d) { return geneY(d)-maxheight/2; })
                  .attr("y2", function(d) { return geneY(d)-maxheight/2; })
                  .attr("stroke", "white");
  
    var vertLine = svgE.selectAll("lines")
                .data(tissues)
                .enter()
                .append("line")
                  .attr("y1", geneY(genes[0])-maxheight/2)
                  .attr("y2", geneY(genes[genes.length-1])+maxheight/2)
                  .attr("x1", function(d) { return tissueX(d)-maxwidth/2; })
                  .attr("x2", function(d) { return tissueX(d)-maxwidth/2; })
                  .attr("stroke", "white");
    // Lines
    var lofLines = svgE.selectAll("lines")
        .data(genes)
        .enter()
        .append("line")
          .attr("x1", 0.125*width)
          .attr("x2", 0.2*width)
          .attr("y1", function(d) { return geneY(d); })
          .attr("y2", function(d) { return geneY(d); })
          .attr("stroke", "lightgrey");
  
    // Lines
    var lofZeroTick = svgE.selectAll("zerolines")
        .data(genes)
        .enter()
        .append("line")
          .attr("x1", eoScale(0))
          .attr("x2", eoScale(0))
          .attr("y1", function(d) { return geneY(d)-height*0.005; })
          .attr("y2", function(d) { return geneY(d)+height*0.005; })
          .attr("stroke", "lightgrey");
  
    var lofOneTick = svgE.selectAll("onelines")
        .data(genes)
        .enter()
        .append("line")
          .attr("x1", eoScale(1))
          .attr("x2", eoScale(1))
          .attr("y1", function(d) { return geneY(d)-height*0.005; })
          .attr("y2", function(d) { return geneY(d)+height*0.005; })
          .attr("stroke", "lightgrey");
  
      // Lines
      var tissueLabels = svgE.selectAll("tissuetext")
              .data(tissues)
              .enter()
              .append("text")
                .attr("id", function(d) { return d;})
                .attr("y", function(d) { return height*0.895;})
                .attr("x", function(d) { return (tissueX(d)-maxwidth*0.3);})
                .text(function(d) { return d; })
                .attr("text-anchor","start")
                .attr("class","gene-labels")
                .attr("transform", function(d) { return "rotate(90,"+(tissueX(d)-maxwidth*0.3) +"," + (height*0.895) + ")"; });
  
      svgE.append("text")
        .text(0)
        .attr("y", geneY(genes[0])-height*0.015)
        .attr("x", eoScale(0))
        .attr("text-anchor","middle")
        .attr("class","eo-labels");
  
      svgE.append("text")
        .text(1)
        .attr("y", geneY(genes[0])-height*0.015)
        .attr("x", eoScale(1))
        .attr("text-anchor","middle")
        .attr("class","eo-labels");
        
      svgE.append("text")
        .text("observed/expected SNV pLOF")
        .attr("y", geneY(genes[0])-height*0.03)
        .attr("x", (eoScale(max_eo)-eoScale(min_eo))/2+eoScale(min_eo))
        .attr("text-anchor","middle")
        .attr("class","eo-labels");
  
      var eoCircles = svgE.selectAll("EOcircle")
        .data(genes)
        .enter()
        .append("circle")
            .attr("id", function (d) { return d; } )
            .attr("stroke", "white")
            .attr("stroke-width", 1)
            .attr("cx", function (d) {
              console.log(d, data["oeLOF"][d]);
              if (!isNaN(data["oeLOF"][d])){
                return eoScale(data["oeLOF"][d]);
              }else{
                return -100;
              }})
            .attr("cy", function (d) {return geneY(d);})
            .attr("r", 3)
            .attr("fill", "#036666");
      // expressionNodes.raise();
      eoCircles.raise();
  
      geneLabels
        .on("mouseover",function(d) { 
          tissueLabels
                .attr("opacity",0.2);
          geneLabels
                .filter(function (g) {return g!=d;})
                .attr("opacity",0.2);
          expressionNodes
                .attr("fill", "lightgrey");
          expressionNodes
            .filter(function (g) {return g.gene==d;})
            .attr("fill", function(g){
              tissueLabels
                .filter(function (t) {return g.tissue==t;})
                .attr("opacity",1);
  
              return "#036666";
            });
        })
        .on("mouseout",function(d) { 
          expressionNodes
            .attr("fill", "#036666");
          tissueLabels
            .attr("opacity",1);
          geneLabels
            .attr("opacity",1);
        });
  
    tissueLabels
        .on("mouseover",function(d) { 
          tissueLabels
                .filter(function (g) {return g!=d;})
                .attr("opacity",0.2);
          geneLabels
                .attr("opacity",0.2);
          expressionNodes
                .attr("fill", "lightgrey");
          expressionNodes
            .filter(function (g) {return g.tissue==d;})
            .attr("fill", function(g){
              geneLabels
                .filter(function (t) {return g.gene==t;})
                .attr("opacity",1);
  
              return "#036666";
            });
        })
        .on("mouseout",function(d) { 
          expressionNodes
            .attr("fill", "#036666");
          tissueLabels
            .attr("opacity",1);
          geneLabels
            .attr("opacity",1);
        });
  // };

  var edges = clusterdata["edges"];
  var nodes = clusterdata["nodes"];
  var node_list = [];
  var tmp = [];


  if(document.getElementById("hpoParents").checked){
    nodes = nodes.concat(clusterdata["hpoParentNodes"]);
    edges = edges.concat(clusterdata["hpoParentEdges"]);
  }

  node_list.forEach(function (o)
   {
    if(o[2]==":"){
      min_d = Math.min(min_d, data.hpoDepth[o]);
      max_d = Math.max(max_d, data.hpoDepth[o]);
    }});      

  var x = d3.scaleLinear()
    .domain([0, 0.75])
    .range([ 0, width]);

  var y = d3.scaleLinear()
      .domain([0, 0.75])
      .range([0, height]);

  // filter nodes and edges from a specific cluster
  nodes.forEach(function(n){node_list.push(n.id)});

  min_d = Number.MAX_VALUE,
  max_d = -Number.MAX_VALUE;
  node_list.forEach(function (o) {
    if(o[2]==":"){
      min_d = Math.min(min_d, data.hpoDepth[o]);
      max_d = Math.max(max_d, data.hpoDepth[o]);
    }});      

  var cScale = d3.scaleLinear()
      .domain([min_d ,max_d])
      .range(["black","lightgrey"]);

  // radial scale
  var radialScale = d3.scaleLinear()
      .domain([min_d, max_d])
      .range([width*5/12, width*2/12]);

  // bipartite scale
  var bipartiteScale = d3.scaleLinear()
      .domain([min_d, max_d])
      .range([width*7/10, width*5/10]);

  // initialize the edges
  var link = svg
    .selectAll("line")
    .data(edges)
    .enter()
    .append("line")
      .style("stroke", "black")
      .style("stroke-width", 1)
      .style("opacity", 0.1);

  svg
    .selectAll("circle")
    .remove();
  
  svg
    .selectAll("rect")
    .remove();
  var node = svg
        .selectAll("circle")
        .data(nodes)
        .enter()
        // .filter(function (d) { return d.cluster==cluster; } )
        .append("circle")
            .attr("id", function (d) { return d.id; } )
            .attr("stroke", "white")
            .attr("stroke-width", 0)
            .attr("cx", function (d) { 
              if(Object.keys(d).includes("x")){
                d.x = x(normX(d.x));
                return x(normX(d.x)); 
              }else{
                d.x = width/2;
                return width/2; 
              }})
            .attr("cy", function (d) { 
              if(Object.keys(d).includes("y")){
                d.y = y(normY(d.y));
                return y(normY(d.y)); 
              }else{
                d.y = height/2;
                return  height/2; 
              }})
            .attr("r", 10)
            .attr("fill", function(d) { 
              if(d.type=="HPO Parent"){
                return "red";
              }
              if (d.id[2]==":"){
                return "#27476E";
              }else{
                return "#059fa0";
              };});

  // initialize the labels
  var labels = svg
    .selectAll("text")
    .data(nodes)
    .enter()
    .append("text")
      .style("font-family","Tahoma")
      .style("font-size","10px")
      .style("opacity", 0.60);
 
  // simulate network with repulision and springs
  var simulation = d3.forceSimulation(nodes)
      .force('charge', d3.forceManyBody())
      .force("link", 
        d3.forceLink()
            .id(function(d) { return d.id; }) // This provide  the id of a node
            .links(edges) // and this the list of links
       )
      .force("charge", d3.forceManyBody().strength(-200)) // repulsion between nodes
      .force("collide", d3.forceCollide(document.getElementById("layout-bipartite").checked ? 10 : 15).iterations(10)) // 15 is raduis and run collisions to reduce overlap
      .force("center", d3.forceCenter(width * .5, height * .5)) // attracts nodes to the center
      .force("radial",d3.forceRadial(d => d.id[2]===":" ? radialScale(data.hpoDepth[d.id]): 0, width / 2, height / 2).strength(d => document.getElementById("layout-HPO").checked ? (d.id[2]===":" ? 5 : 1): 0 ))
      .force("x", d3.forceX().x(d => (d.id[2]===":" ? bipartiteScale(data.hpoDepth[d.id]):width*3/ 10)).strength(d => document.getElementById("layout-bipartite").checked ? 200: 0 ))
      .on("tick", ticked)
      .on("end", function(d){
      // after nodes draw labels
        labels
          .attr("id",function(d) {return d.id})
          .style("background-color","white")
          .attr("x", function (d) { return  (document.getElementById("layout-bipartite").checked ? 0:2) + Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )); })
          .attr("y", function(d) { return (document.getElementById("layout-bipartite").checked ? -4:-8) + Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); })
          .attr("class","nodeID")
          .attr("text-anchor", function(d) {
            if( (2 + Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )))>width/2){
              return "start"
            }else{
              return "end"
            };})
            .text(function(d){
              if(d.id[2]==":"){
                if(document.getElementById("hpoLabel").checked &&  d.id in data.nodeLabels){
                  return data.nodeLabels[d.id];
                }else{
                  return d.id;
                }
              }else{
                if(document.getElementById("geneLabel").checked &&  d.id in data.nodeLabels){
                  return data.nodeLabels[d.id];
                }else{
                  return d.id;
                }
              }
            });

          // link
          //   .filter(function(d){
          //     console.log( d.source.id, d.target.id,(d.source.id[2]!=":" && d.target.id[2]!=":"));
          //     return (d.source.id[2]!=":" && d.target.id[2]!=":");})
          //   .append('path')
          //   .attr('opacity',1)
          //   .attr('d', function (d) {
          //     console.log(d.source.id,d.source.y)
          //     start = d.source.y;   // X position of start node on the X axis
          //     x = d.source.x; 
          //     end = d.target.y;      // X position of end node
          //     return ['M', x, start,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)
          //       'A',                            // This means we're gonna build an elliptical arc
          //       (start - end)/2*4, ',',    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance
          //       (start - end)/2, 0, 0, ',',
          //       start < end ? 1 : 0, x, ',', end] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.
          //       .join(' ');
          //   });
          
        labels
          .on("click", function(d){
            if(d.id[2]==':'){
              window.open("https://hpo.jax.org/app/browse/term/"+d.id);
            }else{
              window.open("https://gnomad.broadinstitute.org/gene/"+d.id);
              window.open("https://gtexportal.org/home/gene/"+d.id);
            };  
            });
        labels
          .raise();
        // return form.enable(); // enable form

          node
          .on('mouseover', function (d) {
            // Highlight the nodes: every node is green except of him
            // Highlight the connections

            if (d.id[2]!=":"){
              geneLabels
                tissueLabels
                      .attr("opacity", 0.2);
                geneLabels
                      .filter(function (g) {return g!=d.id;})
                      .attr("opacity",0.2);
                expressionNodes
                      .attr("fill", "lightgrey");
                expressionNodes
                  .filter(function (g) {return g.gene==d.id;})
                  .attr("fill", function(g){
                    tissueLabels
                      .filter(function (t) {return g.tissue==t;})
                      .attr("opacity",1);
        
                    return "#036666";
                  });

            }
        node
          .style('opacity',0.1);
        labels
          .style('opacity',0.03);
        link
          .style('opacity',0.0);
      
      // d3.selectAll("tspan").filter(function(n) { return n.id === d.id; }).text( d.id[2]===":" ? d.id : (d.id in data.nodeLabels ? data.nodeLabels[d.id]:""));

      link
        .filter(function(link_d){return link_d.source.id === d.id || link_d.target.id === d.id;})
        .style('opacity', function (link_d) { 
            node
              .filter(function(l) { return link_d.source.id === l.id || link_d.target.id === l.id; })
              .style('opacity', 1)
            labels
              .filter(function(l) { return link_d.source.id === l.id || link_d.target.id === l.id; })
              .style('opacity',0.8)
            return 0.3;
        })
    })
    .on('mouseout', function (d) {

      expressionNodes
        .attr("fill", "#036666");
      tissueLabels
        .attr("opacity",1);
      geneLabels
        .attr("opacity",1);

      node
        .style('opacity', 1)
      link
        .style('opacity',  0.1)
      labels
        .style('opacity',  0.6)
    });

      });
  
  // network scaling factor
  var scaling_factor = 1;

  node
      // .filter(function (d) {return document.getElementById("layout-bipartite").checked ? (d.id[2]==":" ? true : false) : true})
      .call(d3.drag().on("drag", dragged))


  // updating the nodes position during dragging
  function dragged(d) {
    d.x =  Math.max(margin.left, Math.min(width - margin.left, d3.event.x));
    d.y = Math.max(margin.top, Math.min(width - margin.top, d3.event.y));

    d3.select(this).attr("cx", d.x*scaling_factor).attr("cy", d.y*scaling_factor);
    link.filter(function(l) { return l.source === d; }).attr("x1", d.x*scaling_factor).attr("y1", d.y*scaling_factor);
    link.filter(function(l) { return l.target === d; }).attr("x2", d.x*scaling_factor).attr("y2", d.y*scaling_factor);
    labels.filter(function(n) { return n.id === d.id; })
          .attr("x", 2+d.x*scaling_factor)
          .attr("y",-10+d.y*scaling_factor)
          .attr("text-anchor", function(d) {
            if( (2 + Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )))>width/2){
              return "start"
            }else{
              return "end"
            };});
    d3.selectAll("tspan").filter(function(n) { return n.id === d.id; }).attr("x", 10+d.x*scaling_factor).attr("y",-2+d.y*scaling_factor);
    node
        .style('opacity', 1)
      link
        .style('opacity',  0.1)
      labels
        .style('opacity',  0.5)
  }
  // run after force simulation
  
  function ticked() {
    //draw nodes
    node
      .interrupt()
      .attr("stroke", "White")
      .style("stroke-width",1)
      .style("fill", function (d) {
        if (d.id[2]==":"){
          return cScale(parseInt(data.hpoDepth[d.id]));
        }else{
          return "#059fa0";
          // if (!Object.keys(tissues).includes(d.id)){
          //   return "light blue";
          // }else{
          //   return "light blue";//geneColors(tissues[d.id]);
          // };
        }
      })
      .attr("cx", function (d) { 
        d.x = Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor ));
        return Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )); })
      .attr("cy", function(d) {
        d.y = Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); 
        return Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); })
      .attr("r", function(d) {return document.getElementById("layout-bipartite").checked ? 5: (selectedNodes.includes(d.id)? 12:8)})

    // raise nodes above edges
    node
      .raise();
    // draw edges

    link
      .style('opacity',  0.1)
      .attr("x1", function(d) { return Math.max(margin.left, Math.min(width - margin.left, d.source.x*scaling_factor )); })
      .attr("y1", function(d) { return Math.max(margin.left, Math.min(height - margin.left, d.source.y*scaling_factor ));})
      .attr("x2", function(d) { return Math.max(margin.left, Math.min(width - margin.left, d.target.x*scaling_factor )); })
      .attr("y2", function(d) { return Math.max(margin.left, Math.min(height - margin.left, d.target.y*scaling_factor )); });
    };


  })})};

  function updateColors(){
    if(true){
      var tissues = {};
      nodes.forEach(function(n){
        if(n.id[2]!=":" && Object.keys(data["tissueExpression"][n.id]).includes("specificity")){
          let geneExpression = data["tissueExpression"][n.id];
          geneExpression["specificity"] =-1;
          tissues[n.id] = Object.entries(geneExpression).reduce((a, b) => a[1] > b[1] ? a : b)[0];
        }
      });

      uniqueTissues = [new Set(Object.keys(tissues))];
      var geneColors = d3.scaleOrdinal()
                          .domain(uniqueTissues)
                          .range(d3.schemeCategory10);
    }
    svg
      .selectAll("circle")
  }
  function updateLabels(){
    // update HPO terms
    svg
      .selectAll("text")
      .text(function(d){
        if(d.id[2]==":"){
          if(document.getElementById("hpoLabel").checked &&  d.id in data.nodeLabels){
            return data.nodeLabels[d.id];
          }else{
            return d.id;
          }
        }else{
          if(document.getElementById("geneLabel").checked &&  d.id in data.nodeLabels){
            return data.nodeLabels[d.id];
          }else{
            return d.id;
          }
        }
      })

    // update HPO terms
  };
  ////////////////////////
  // GENES/HP TERM FORM //
  ////////////////////////
  
  function displayCluster(cluster_info, selections){
    var cluster = cluster_info["cluster"];


    // clean up network drawing
    // svg.selectAll("circle")
    //   .attr("fill", function(d) { 
    //         if (d.id[2]==":"){
    //           return "#27476E";
    //         }else{
    //           return "#81ADC8";
    //         };});
              
    svg.selectAll("line").remove();
    svg.selectAll("text").remove();
    svg.selectAll("circle")
      // .filter(function(d){return cluster!=d.cluster;})
      .remove();
    
    if(cluster==cluster){
      // ENTER CLUSTER NODES

      // geneLayout(cluster, selections);
      forceDirected(cluster, selections);
      updateLabels();
    }else{
      loadAll();
    }
    
  }
  
  function processSelection(ranking = 1,selections = form.items) {
    if(selections.length>0){
      let sortByCount = document.getElementById("sort-count").checked;
      // filter to only the filter nodes
      let filteredClusters = {};
      var node;
      var selectedClusters = [];
      // count genes and hpo terms in cluster
        // union of all cluster with selected genes and HPS
        // for each selection
        // find clusters it is in and add one to cluster score
        for (let i = 0; i < selections.length; i++) {
          if(data.clusters.includes(selections[i])){
            selectedClusters.push(selections[i])
            
            if (!(selections[i] in filteredClusters)){// if cluster has already been added to dict, update its count
                filteredClusters[selections[i]] = {}
                filteredClusters[selections[i]]["HPO count"] = 0;
                filteredClusters[selections[i]]["gene count"] = 0;
                filteredClusters[selections[i]]["count"] = 0;
                filteredClusters[selections[i]]["pval"] = data.pval[selections[i]];
              }
          }else{
          data.nodes.forEach(function(node){
            if( node.id == selections[i]){
              if (Object.keys(filteredClusters).includes(node.cluster)){// if cluster has already been added to dict, update its count
                filteredClusters[node.cluster][((node.id[2]==":") ? "HPO count" : "gene count")] += 1;
                filteredClusters[node.cluster]["count"] += 1;
              }else{// if cluster hasnt then add to dict
                filteredClusters[node.cluster] = {}
                filteredClusters[node.cluster]["HPO count"] = ((node.id[2]==":") ? 1 : 0);
                filteredClusters[node.cluster]["gene count"] = ((node.id[2]==":") ? 0 : 1);
                filteredClusters[node.cluster]["count"] = 1;
                filteredClusters[node.cluster]["pval"] = data.pval[node.cluster];
              }
            }
          })
        }
        }
      
      // convert dict to list of dicts
      var rankedClusters = [];
      Object.keys(filteredClusters).forEach(function(cluster){
        if(selectedClusters.length==0 || selectedClusters.includes(cluster) ){
          rankedClusters.push({"cluster":cluster,
                              "HPO count": filteredClusters[cluster]["HPO count"],
                              "gene count": filteredClusters[cluster]["gene count"],
                              "count": filteredClusters[cluster]["count"],
                              "pval": filteredClusters[cluster]["pval"]});
          }});

    // Sort by either count or pval, break ties with other metric
      rankedClusters = rankedClusters.sort(function (a, b) {
        if(sortByCount){
          return b["count"] - a["count"] || a["pval"] - b["pval"];
        }else{
          return  a["pval"] - b["pval"] || b["count"] - a["count"];
        }
      });

      // console.log(rankedClusters, selections)
      document.getElementById("cluster-info").hidden = "";
      document.getElementById("current-cluster").innerHTML = ranking;
      document.getElementById("total-clusters").innerHTML = rankedClusters.length;
      document.getElementById("cluster-id").innerHTML = rankedClusters[ranking-1]["cluster"];
      document.getElementById("matching-count").innerHTML = rankedClusters[ranking-1]["count"];
      document.getElementById("total-count").innerHTML = selections.length-selectedClusters.length;
      document.getElementById("pval").innerHTML = rankedClusters[ranking-1]["pval"].toPrecision(4);

      if( ranking<rankedClusters.length){document.getElementById("next").hidden = "";
      }else{ document.getElementById("next").hidden = "hidden";}

      if(ranking>1){document.getElementById("previous").hidden = "";
      }else{document.getElementById("previous").hidden = "hidden";}

      displayCluster(rankedClusters[ranking-1], selections);
  }else{
    svg.selectAll("line").remove();
    svg.selectAll("text").remove();
    svg.selectAll("circle").remove();
    svgE.selectAll("line").remove();
    svgE.selectAll("text").remove();
    svgE.selectAll("circle").remove();
    svgE.selectAll("rect").remove();
    document.getElementById("previous").hidden = "hidden";
    document.getElementById("next").hidden = "hidden";
    document.getElementById("cluster-info").hidden = "hidden";
    loadAll();
  }
  };

  function buildSelectize(){
    var optionsArray = [];
    
    data.genes.forEach(function(o){optionsArray.push({name:o + (o in data.nodeLabels ? " - " + data.nodeLabels[o]: ""), value:o, group:"gene"})});
    data.diseases.forEach(function(o){optionsArray.push({name:o + (o in data.nodeLabels ? " - " + data.nodeLabels[o]: ""), value:o, group:"HP"})});
    data.clusters.forEach(function(o){optionsArray.push({name:o, value:o, group:"cluster"})});

    $form = $("#select-node")
                .selectize({
                      valueField: 'value',
                      labelField: 'name',
                      searchField: ['name'],
                      options: optionsArray,
                      optgroups:[
                        {value:"gene", label: "gene"},
                        {value:"HP", label: "HP"},
                        {value:"cluster", label: "cluster"},
                      ],
                      optgroupField: 'group',
                      delimiter:',',
                      create: false,
                      hideSelected: true,
                      sortField: "text",
                      maxItems: 20,
                      text:true,
                      // onChange: function (){updateSelectize();},
                      onDropdownClose: function (){processSelection(1);}
                  });

    form = $form[0].selectize;   
    form.setValue([])  
  }   
  function clickNext(){
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML)+1);
  };

  function clickPrevious(){
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML)-1);
  };

  document.getElementById("sort-form-title").addEventListener('click',function(){
    if(document.getElementById("sort-form").hidden){
      document.getElementById("sort-form").hidden="";
      document.getElementById("sort-form-title").innerHTML=" cluster ranking &and; ";
    }else{
      document.getElementById("sort-form").hidden="hidden";
      document.getElementById("sort-form-title").innerHTML=" cluster ranking &or; ";
    }
  });

  document.getElementById("layout-form-title").addEventListener('click',function(){
    if(document.getElementById("layout-form").hidden){
      document.getElementById("layout-form").hidden="";
      document.getElementById("layout-form-title").innerHTML=" view &and; ";
    }else{
      document.getElementById("layout-form").hidden="hidden";
      document.getElementById("layout-form-title").innerHTML=" view &or; ";
    }
  });

  document.getElementById("misc-form-title").addEventListener('click',function(){
    if(document.getElementById("misc-form").hidden){
      document.getElementById("misc-form").hidden="";
      document.getElementById("misc-form-title").innerHTML=" display &and; ";
    }else{
      document.getElementById("misc-form").hidden="hidden";
      document.getElementById("misc-form-title").innerHTML=" display &or; ";
    }
  });

  $('.next').mousedown(function(){clickNext();});
  $('.searchDropdown').mousedown( function(){$('.searchFilters').collapse('toggle');});
  $('.previous').mousedown(function(){clickPrevious();});
  document.getElementById("sort-form").addEventListener('click', function (event) {
    if (event.target && event.target.matches("input[type='radio']")) {
        processSelection();
    }
  });

  document.getElementById("hpoParents").addEventListener('click',function(){processSelection(parseInt(document.getElementById("current-cluster").innerHTML));});
  document.getElementById("hpoLabel").addEventListener('click',function(){updateLabels();});
  document.getElementById("geneLabel").addEventListener('click',function(){updateLabels();});
  // document.getElementById("geneExpression").addEventListener('click',function(){updateColors();});

  document.getElementById("layout-form").addEventListener('click', function (event) {
  if (event.target && event.target.matches("input[type='radio']")) {
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML));
  }
});



});


    </script>