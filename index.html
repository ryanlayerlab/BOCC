<!DOCTYPE html>

<meta charset="utf-8">

<head>
  <link rel="stylesheet" href="styles.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.12.6/js/standalone/selectize.min.js" integrity="sha256-+C0A5Ilqmu4QcSPxrlGpaZxJ04VjsRjKu+G82kl5UJk=" crossorigin="anonymous"></script>

  <script src="https://cdn.jsdelivr.net/npm/d3-dispatch@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-selection@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-drag@3"></script>

  <script src="https://d3js.org/d3.v4.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.12.6/css/selectize.bootstrap3.min.css" integrity="sha256-ze/OEYGcFbPRmvCnrSeKbRTtjG4vGLHXgOqsyLFTRjg=" crossorigin="anonymous" />
  
</head>
<body>
<!-- Create a div where the graph will take place -->
<div  style="text-align:left;font-family: Verdana, sans-serif;font-size: 30px;color:#3C769D;">BOCC Visualization</div>
<div  style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#3C769D;">Search clusters by filtering by genes or diseases of interest</div>
<br>

<div  style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#3C769D;max-width: 50%;">
  <select id="select-node"  placeholder="Filter by genes or HP terms...",  size="2"></select>
</div>
<div id="sort-form" style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#7b7b7b;max-width: 50%;"> 
    Sort by:
    <input type="radio" class="form-check-input" id="sort-count" name="optradio" value="option1" checked>
    <label class="form-check-label" for="radio1">matching terms</label>
    <input type="radio" class="form-check-input" id="sort-pvalue" name="optradio" value="option2">
    <label class="form-check-label" for="radio2">discovery pvalue</label>
</div>  

<div id="layout-form" style="text-align:left;font-family: Verdana, sans-serif;font-size: 12px;color:#7b7b7b;max-width: 50%;"> 
  Network Layout:
  <input type="radio" class="form-check-input" id="layout-spring" name="optradio1" value="option1" checked>
  <label class="form-check-label" for="radio1">spring layout</label>
  <input type="radio" class="form-check-input" id="layout-HPO" name="optradio1" value="option2">
  <label class="form-check-label" for="radio2">HPO hierarchy</label>
</div>  

<table id="cluster-info" class="center" hidden="hidden" style="text-align:center;font-family: Verdana, sans-serif;font-size: 12px;color:#252525;">
  <tr>
    <td>
      <a id="previous" class="previous" hidden="hidden"> &#8249; </a>
    </td>
    <td>
      <small>Cluster <span id="current-cluster">10</span> of <span id="total-clusters">50</span></small><br>
      <small>Cluster ID: <span id="cluster-id">ParisWalkYrap</span></small><br>
      <small>Matching Search Terms: <span id="matching-count">1</span>/<span id="total-count">10</span></small><br>
      <small>Discovery P-Value: <span  id="pval">0.234</span></small><br>
    </td>
    <td>
      
      <a id="next" class="next" hidden="hidden">&#8250;</a>
    </td>
  </td>
  </td>
</table>

<div id="my_dataviz"></div>
</body>
<script>
  

    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 10, bottom: 10, left: 10},
      width = 800 - margin.left - margin.right,
      height = 800 - margin.top - margin.bottom;

    let zoom = d3.zoom()
      .scaleExtent([1, 20])
      .translateExtent([[0, 0], [width, height]]);

    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform","translate(" + margin.left + "," + margin.top + ")");

    d3.json("https://sky123martin.github.io/BOCC/network_extended.json", function(err,data){


        // append the svg object to the body of the page
      min_x = Number.MAX_VALUE,
      max_x = -Number.MAX_VALUE;
      min_y = Number.MAX_VALUE,
      max_y = -Number.MAX_VALUE;
      console.log(err);
      console.log(data);
      console.log(Object.keys(data));
      data.nodes.forEach(function (o) {
                min_x = Math.min(min_x, o["x"]);
                max_x = Math.max(max_x, o["x"]);
                min_y = Math.min(min_y, o["y"]);
                max_y = Math.max(max_y, o["y"]);
        });

      // Add X axis
      var normX = d3.scaleLinear()
          .domain([min_x, max_x])
          .range([0, 0.75]);

      // Add Y axis
      var normY = d3.scaleLinear()
          .domain([min_y, max_y])
          .range([0, 0.75]);
      
      var xZoom = d3.scaleLinear()
        .domain([min_x, max_x])
        .range([ 0, width ]);

      // Add Y axis
      var yZoom = d3.scaleLinear()
          .domain([min_y, max_y])
          .range([ height, 0]);

      // function selectCluster(cluster_id){
      //   svg.selectAll("circle")
      //     .filter(function(d){ return cluster_id!=d.cluster_id})
      //     .style("fill", "#CAD1E9")
      //     .attr("cx", function (d) { return x(gridX(d.cluster_id)+normX(d.x)); } )
      //     .attr("cy", function (d) { return y(gridY(d.cluster_id)+normY(d.y)); } )

      //   svg.selectAll("circle")
      //     .filter(function(d){ return cluster_id==d.cluster})
      //     .style("fill", "#3C769D")
      //     .transition()
      //     .duration(100)
      //     .attr("cx", function (d) { return x(gridX(d.cluster_id)+normX(1.5*d.x)); } )
      //     .attr("cy", function (d) { return y(gridY(d.cluster_id)+normY(1.5*d.y)); } )
      // }
      // function unselectCluster(cluster_id){
      //   svg.selectAll("circle")
      //     .transition()
      //     .duration(100)
      //     .style("fill", "#3C769D")
      //     .attr("cx", function (d) { return x(gridX(d.cluster_id)+normX(d.x)); } )
      //     .attr("cy", function (d) { return y(gridY(d.cluster_id)+normY(d.y)); } )
      // }

      // function clickCluster(cluster_id){
      //   svg.selectAll("circle")
      //     .filter(function(d){ return cluster_id==d.cluster_id})
      //     .transition()
      //     .duration(100)
      //     .attr("cx", function (d) { return x(gridX(d.cluster_id)+normX(1.5*d.x)); } )
      //     .attr("cy", function (d) { return y(gridY(d.cluster_id)+normY(1.5*d.y)); } )
      // }

  // ONLOAD

  function loadAll(){
    let max_clusters = data["# of clusters"]
      // Add X axis
      let grid_size = Math.ceil(Math.sqrt(max_clusters));
      var x = d3.scaleLinear()
        .domain([0, grid_size])
        .range([ 0, width ]);

      // Add Y axis
      var y = d3.scaleLinear()
          .domain([0, grid_size])
          .range([0, height]);
    
      function gridY(a) {return Math.ceil(a/grid_size);}
      function gridX(a) {return a%grid_size;}

      var node = svg
        .selectAll("circle")
        .data(data.nodes)
        .enter()
        .append("circle")
            .attr("id", function (d) { return d.id; } )
            .attr("stroke", "white")
            .attr("stroke-width", 0)
            .attr("cx", function (d) { 
              d.defaultx = d.x;
              return x(gridX(d.cluster_id)+normX(d.x)); } )
            .attr("cy", function (d) { 
              d.defaulty = d.y;
              return y(gridY(d.cluster_id)+normY(d.y)); } )
            .attr("r", 1)
            .attr("fill", function(d) { 
              if (d.id[2]==":"){
                return "#27476E";
              }else{
                return "#81ADC8";
              };});
              
  // displayCluster(["paris.infomap.2021:1880"],["BRCA1"]);
  // displayCluster(["paris.cesna.2021:3199"],[]);     
  }

  $(document).ready(function() {
    buildSelectize();
    loadAll();
  });

// FORCE DIRECTED LAYOUT
function forceDirected(cluster, selectedNodes) {
  d3.json("https://raw.githubusercontent.com/sky123martin/BOCC/main/clusters/"+cluster.replace(":",".")+".json", function(clusterdata) {

  var edges = clusterdata["edges"];
  var nodes = clusterdata["nodes"];
  var node_list = [];

  node_list.forEach(function (o) {
    if(o[2]==":"){
      min_d = Math.min(min_d, data.hpoDepth[o]);
      max_d = Math.max(max_d, data.hpoDepth[o]);
    }});      

  var x = d3.scaleLinear()
    .domain([0, 0.75])
    .range([ 0, width]);

  var y = d3.scaleLinear()
      .domain([0, 0.75])
      .range([0, height]);

  // filter nodes and edges from a specific cluster
  // data.nodes.forEach(function(n){if(n.cluster==cluster){nodes.push(n);}});
  nodes.forEach(function(n){node_list.push(n.name)});
  // data.edges.forEach(function(e){if(node_list.includes(e.source) & node_list.includes(e.target)){edges.push(e);}});
  min_d = Number.MAX_VALUE,
  max_d = -Number.MAX_VALUE;
  node_list.forEach(function (o) {
    if(o[2]==":"){
      min_d = Math.min(min_d, data.hpoDepth[o]);
      max_d = Math.max(max_d, data.hpoDepth[o]);
    }});      
  var cScale = d3.scaleLinear()
      .domain([min_d ,max_d])
      .range(["black", "lightgrey"]);

  // radial scale
  var radialScale = d3.scaleLinear()
      .domain([min_d, max_d])
      .range([width*5/12, width*2/12]);

  // initialize the edges
  var link = svg
    .selectAll("line")
    .data(edges)
    .enter()
    .append("line")
      .style("stroke", "black")
      .style("stroke-width", 1)
      .style("opacity", 0.1);

  // initialize the nodes

  svg
    .selectAll("circle")
    .remove();

  var node = svg
        .selectAll("circle")
        .data(clusterdata.nodes)
        .enter()
        // .filter(function (d) { return d.cluster==cluster; } )
        .append("circle")
            .attr("id", function (d) { return d.id; } )
            .attr("stroke", "white")
            .attr("stroke-width", 0)
            .attr("cx", function (d) { 
              d.x = x(normX(d.x));
              return x(normX(d.x)); } )
            .attr("cy", function (d) { 
              d.y = y(normY(d.y));
              return y(normY(d.y)); } )
            .attr("r", 10)
            .attr("fill", function(d) { 
              if (d.id[2]==":"){
                return "#27476E";
              }else{
                return "#81ADC8";
              };});

  // initialize the labels
  var labels = svg
    .selectAll("text")
    .data(nodes)
    .enter()
    .append("text")
      .style("font-family","Tahoma")
      .style("font-size","10px")
      // .style("color","black")
      .style("opacity", 0.50);

  // simulate network with repulision and springs
  var simulation = d3.forceSimulation(nodes)
      .force('charge', d3.forceManyBody())
      .force("link", 
        d3.forceLink()
            .id(function(d) { return d.id; }) // This provide  the id of a node
            .links(edges) // and this the list of links
       )
      .force("charge", d3.forceManyBody().strength(-200)) // repulsion between nodes
      .force("collide", d3.forceCollide(30).iterations(20)) // 15 is raduis and run collisions to reduce overlap
      .force("center", d3.forceCenter(width * .5, height * .5)) // attracts nodes to the center
      .force("radial",d3.forceRadial(d => d.id[2]===":" ? radialScale(data.hpoDepth[d.id]): width/10, width / 2, height / 2).strength(d => document.getElementById("layout-HPO").checked ? (d.id[2]===":" ? 10 : 2): 0 ))
      .on("tick", ticked)
      .on("end", function(d){
      // after nodes draw labels
        labels
          .attr("x", function (d) { return   2 + Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )); })
          .attr("y", function(d) { return -10 + Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); })
          .attr("text-anchor", function(d) {
            if(d.id[2]!=":"){
              return "middle"
            }else if( (2 + Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )))>width/2){
              return "start"
            }else{
              return "end"
            };})
          .text(function(d) {
            if(d.id[2]==":" && d.id in data.nodeLabels){
              return data.nodeLabels[d.id];//.slice(3);
            }else{
              return d.id;
            };})
        labels
            .on("click", function(d){
            if(d.id[2]==':'){
              window.open("https://hpo.jax.org/app/browse/term/"+d.id);
            }else{
              window.open("https://gnomad.broadinstitute.org/gene/"+d.id);
              window.open("https://gtexportal.org/home/gene/"+d.id);
            };  
            })
          labels
            .raise();
        return form.enable(); // enable form
      });
  
  // network scaling factor
  var scaling_factor = 1;

  node
      .call(d3.drag().on("drag", dragged))

  node
    .on('mouseover', function (d) {
      // Highlight the nodes: every node is green except of him
      // Highlight the connections
      node
        .style('opacity',0.6)
      labels
        .style('opacity',0.05)
      link
        .style('opacity',0.05)

      link
        .filter(function(link_d){return link_d.source.id === d.id || link_d.target.id === d.id;})
        .style('opacity', function (link_d) { 
            node
              .filter(function(l) { return link_d.source.id === l.id || link_d.target.id === l.id; })
              .style('opacity', 1)
            labels
              .filter(function(l) { return link_d.source.id === l.id || link_d.target.id === l.id; })
              .style('opacity',0.7)
            return 0.4;
        })
    })
    .on('mouseout', function (d) {
      node
        .style('opacity', 1)
      link
        .style('opacity',  0.1)
      labels
        .style('opacity',  0.5)
    });

  // updating the nodes position during dragging
  function dragged(d) {
    d.x = d3.event.x, d.y = d3.event.y;
    d3.select(this).attr("cx", d.x*scaling_factor).attr("cy", d.y*scaling_factor);
    link.filter(function(l) { return l.source === d; }).attr("x1", d.x*scaling_factor).attr("y1", d.y*scaling_factor);
    link.filter(function(l) { return l.target === d; }).attr("x2", d.x*scaling_factor).attr("y2", d.y*scaling_factor);
    labels.filter(function(n) { return n.id === d.id; }).attr("x", 2+d.x*scaling_factor).attr("y",-10+d.y*scaling_factor);
    node
        .style('opacity', 1)
      link
        .style('opacity',  0.1)
      labels
        .style('opacity',  0.5)
  }
  // run after force simulation
  
  function ticked() {
    //draw nodes
    node
      .interrupt()
      .style("fill", function (d) { 
        if (d.id[2]==":"){
          return cScale(data.hpoDepth[d.id]);
        }else{
          return "lightblue";
        }
      })
      .attr("cx", function (d) { 
        d.x = Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor ));
        return Math.max(margin.left, Math.min(width - margin.left, d.x*scaling_factor )); })
      .attr("cy", function(d) {
        d.y = Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); 
        return Math.max(margin.top, Math.min(width - margin.top, d.y*scaling_factor )); })
      .attr("r",  function(d) {
        if(selectedNodes.includes(d.id)){
          return 20
        }else{
          return 10
        }
      })
    // raise nodes above edges
    node
      .raise();
    // draw edges

    link
      .attr("x1", function(d) { return Math.max(margin.left, Math.min(width - margin.left, d.source.x*scaling_factor )); })
      .attr("y1", function(d) { return Math.max(margin.left, Math.min(height - margin.left, d.source.y*scaling_factor ));})
      .attr("x2", function(d) { return Math.max(margin.left, Math.min(width - margin.left, d.target.x*scaling_factor )); })
      .attr("y2", function(d) { return Math.max(margin.left, Math.min(height - margin.left, d.target.y*scaling_factor )); });
    };


    })};

  ////////////////////////
  // GENES/HP TERM FORM //
  ////////////////////////
  
  function displayCluster(cluster_info, selections){
    var cluster = cluster_info["cluster"];


    // clean up network drawing
    svg.selectAll("circle")
      .attr("fill", function(d) { 
            if (d.id[2]==":"){
              return "#27476E";
            }else{
              return "#81ADC8";
            };});
              
    svg.selectAll("line").remove();
    svg.selectAll("text").remove();
    
    // remove all nodes
    svg.selectAll("circle")
      .filter(function(d){return cluster!=d.cluster;})
      .remove()
    
    if(cluster==cluster){
      // ENTER CLUSTER NODES
      forceDirected(cluster, selections);
    }else{
      loadAll()
      // svg.selectAll("circle")
      //   .filter(function(d){return filteredClusters.includes(d.cluster);})
      //   .transition()
      //   .duration(1000)
      //     .attr("cx", function (d) { return x(gridX(cluster_id_lookup[d.cluster])+normX(d.defaultx));} )
      //     .attr("cy", function (d) { return y(gridY(cluster_id_lookup[d.cluster])+normY(d.defaulty));} )
      //     .attr("r", 1)
      //     .attr("fill", function(d) { 
      //         if (d.id[2]==":"){
      //           return "#27476E";
      //         }else{
      //           return "#81ADC8";
      //         };})
      //     .on("end",form.enable())
          
      // svg.selectAll("circle")
      //   .data(data.nodes)
      //   .enter()
      //   .append("circle")
      //       .filter(function(d){
      //         return (hiddenClusters.includes(d.cluster));})
      //       .transition()
      //       .delay(1000)
      //       .attr("id", function (d) { 
      //         console.log(d.id);
      //         return d.id; } )
      //       .attr("cx", function (d) { 
      //         d.defaultx = d.x;
      //         return x(gridX(cluster_id_lookup[d.cluster])+normX(d.x)); } )
      //       .attr("cy", function (d) { 
      //         d.defaulty = d.y;
      //         return y(gridY(cluster_id_lookup[d.cluster])+normY(d.y)); } )
      //       .attr("r", 1)
      //       .attr("fill", function(d) { 
      //         if (d.id[2]==":"){
      //           return "#27476E";
      //         }else{
      //           return "#81ADC8";
      //         };});
    }
  }
  
  function processSelection(ranking=1) {
    let selections = form.items;
    if (selections.length>0){
      let sortByCount = document.getElementById("sort-count").checked;
      // filter to only the filter nodes
      let filteredClusters = {};
      var node;

      // count genes and hpo terms in cluster
      if (selections.length > 0){
        // union of all cluster with selected genes and HPS
        // for each selection
        // find clusters it is in and add one to cluster score
        for (let i = 0; i < selections.length; i++) {
          data.nodes.forEach(function(node){
            if( node.id == selections[i]){
              if (Object.keys(filteredClusters).includes(node.cluster)){// if cluster has already been added to dict, update its count
                filteredClusters[node.cluster][((node.id[2]==":") ? "HPO count" : "gene count")] += 1;
                filteredClusters[node.cluster]["count"] += 1;
              }else{// if cluster hasnt then add to dict
                filteredClusters[node.cluster] = {}
                filteredClusters[node.cluster]["HPO count"] = ((node.id[2]==":") ? 1 : 0);
                filteredClusters[node.cluster]["gene count"] = ((node.id[2]==":") ? 0 : 1);
                filteredClusters[node.cluster]["count"] = 1;
                filteredClusters[node.cluster]["pval"] = data.pval[node.cluster];
              }
            }
          })
        }
      }
      // convert dict to list of dicts
      var rankedClusters = [];
      Object.keys(filteredClusters).forEach(function(cluster){
        rankedClusters.push({"cluster":cluster,
                            "HPO count": filteredClusters[cluster]["HPO count"],
                            "gene count": filteredClusters[cluster]["gene count"],
                            "count": filteredClusters[cluster]["count"],
                            "pval": filteredClusters[cluster]["pval"]});
      });

    // Sort by either count or pval, break ties with other metric
      rankedClusters = rankedClusters.sort(function (a, b) {
        if(sortByCount){
          return b["count"] - a["count"] || a["pval"] - b["pval"];
        }else{
          return  a["pval"] - b["pval"] || b["count"] - a["count"];
        }
      });

      // console.log(rankedClusters, selections)
      document.getElementById("cluster-info").hidden = "";
      document.getElementById("current-cluster").innerHTML = ranking;
      document.getElementById("total-clusters").innerHTML = rankedClusters.length;
      document.getElementById("cluster-id").innerHTML = rankedClusters[ranking-1]["cluster"];
      document.getElementById("matching-count").innerHTML = rankedClusters[ranking-1]["count"];
      document.getElementById("total-count").innerHTML = selections.length;
      document.getElementById("pval").innerHTML = rankedClusters[ranking-1]["pval"];

      if( ranking<rankedClusters.length){document.getElementById("next").hidden = "";
      }else{ document.getElementById("next").hidden = "hidden";}

      console.log(ranking, rankedClusters.length)
      if( ranking>1){document.getElementById("previous").hidden = "";
      }else{document.getElementById("previous").hidden = "hidden";}

      console.log(rankedClusters[ranking-1])
      displayCluster(rankedClusters[ranking-1], selections);
  }else{
    svg.selectAll("line").remove();
    svg.selectAll("text").remove();
    svg.selectAll("circle").remove();
    document.getElementById("cluster-info").hidden = "hidden";
    loadAll();
  }
  };
  
  function updateSelectize(){
    var selectedOptions = Array.from(form.items);
    var optionsArray = [];
    console.log(selectedOptions)
    data.genes.forEach(function(o){if(!selectedOptions.includes(o)){optionsArray.push({name:o, value:o, group:"gene"})}});
    data.diseases.forEach(function(o){if(!selectedOptions.includes(o)){optionsArray.push({name:o, value:o, group:"HP"})}});
    data.clusters.forEach(function(o){if(!selectedOptions.includes(o)){optionsArray.push({name:o, value:o, group:"cluster"})}});
    form.clearOptions();
    optionsArray.forEach(function(o){form.addOption(o)})
  }

  function buildSelectize(){
    var optionsArray = [];
    
    data.genes.forEach(function(o){optionsArray.push({name:o, value:o, group:"gene"})});
    data.diseases.forEach(function(o){optionsArray.push({name:o, value:o, group:"HP"})});
    data.clusters.forEach(function(o){optionsArray.push({name:o, value:o, group:"cluster"})});

    $form = $("#select-node")
                .selectize({
                      valueField: 'name',
                      labelField: 'value',
                      searchField: ['name'],
                      options: optionsArray,
                      optgroups:[
                        {value:"gene", label: "gene"},
                        {value:"HP", label: "HP"},
                        {value:"cluster", label: "cluster"},
                      ],
                      optgroupField: 'group',
                      delimiter:',',
                      create: false,
                      sortField: "text",
                      maxItems: 10,
                      text:true,
                      onChange: function (){updateSelectize();},
                      onDropdownClose: function (){processSelection(1);}
                  });

    form = $form[0].selectize;   
    form.setValue([])  
  }   
  function clickNext(){
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML)+1);
  };

  function clickPrevious(){
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML)-1);
  };

  $('.next').mousedown(function(){clickNext();});
  $('.previous').mousedown(function(){clickPrevious();});
  document.getElementById("sort-form").addEventListener('click', function (event) {
    if (event.target && event.target.matches("input[type='radio']")) {
        processSelection();
    }
  });
  document.getElementById("layout-form").addEventListener('click', function (event) {
  if (event.target && event.target.matches("input[type='radio']")) {
    processSelection(parseInt(document.getElementById("current-cluster").innerHTML));
  }
});
});


    </script>